begin;

create table if not exists public.starred_messages (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  message_id text not null,
  snapshot_content text not null default '',
  snapshot_content_type text not null default 'assistant',
  snapshot_timestamp timestamptz not null default now(),
  starred_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

do $$
begin
  if exists (
    select 1
    from information_schema.columns
    where table_schema = 'public'
      and table_name = 'starred_messages'
      and column_name = 'created_at'
  ) and not exists (
    select 1
    from information_schema.columns
    where table_schema = 'public'
      and table_name = 'starred_messages'
      and column_name = 'starred_at'
  ) then
    alter table public.starred_messages rename column created_at to starred_at;
  end if;
end $$;

alter table public.starred_messages add column if not exists snapshot_content text;
alter table public.starred_messages add column if not exists snapshot_content_type text;
alter table public.starred_messages add column if not exists snapshot_timestamp timestamptz;
alter table public.starred_messages add column if not exists starred_at timestamptz;
alter table public.starred_messages add column if not exists updated_at timestamptz;

update public.starred_messages
set snapshot_content = coalesce(snapshot_content, '')
where snapshot_content is null;

update public.starred_messages
set snapshot_content_type = case
  when snapshot_content_type = 'user' then 'user'
  when snapshot_content_type = 'assistant' then 'assistant'
  else 'assistant'
end
where snapshot_content_type is null
   or snapshot_content_type not in ('user', 'assistant');

update public.starred_messages
set starred_at = coalesce(starred_at, now())
where starred_at is null;

update public.starred_messages
set snapshot_timestamp = coalesce(snapshot_timestamp, starred_at, now())
where snapshot_timestamp is null;

update public.starred_messages
set updated_at = coalesce(updated_at, starred_at, now())
where updated_at is null;

alter table public.starred_messages
  alter column snapshot_content set default '',
  alter column snapshot_content set not null,
  alter column snapshot_content_type set default 'assistant',
  alter column snapshot_content_type set not null,
  alter column snapshot_timestamp set default now(),
  alter column snapshot_timestamp set not null,
  alter column starred_at set default now(),
  alter column starred_at set not null,
  alter column updated_at set default now(),
  alter column updated_at set not null;

do $$
begin
  if not exists (
    select 1
    from pg_constraint
    where conname = 'starred_messages_snapshot_content_type_check'
      and conrelid = 'public.starred_messages'::regclass
  ) then
    alter table public.starred_messages
      add constraint starred_messages_snapshot_content_type_check
      check (snapshot_content_type in ('user', 'assistant'));
  end if;
end $$;

create unique index if not exists starred_messages_user_message_unique
  on public.starred_messages (user_id, message_id);

drop index if exists public.starred_messages_user_created_idx;
create index if not exists starred_messages_user_starred_at_idx
  on public.starred_messages (user_id, starred_at desc);

create or replace function public.set_starred_messages_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

drop trigger if exists set_starred_messages_updated_at on public.starred_messages;
create trigger set_starred_messages_updated_at
before update on public.starred_messages
for each row
execute function public.set_starred_messages_updated_at();

insert into public.starred_messages (
  user_id,
  message_id,
  snapshot_content,
  snapshot_content_type,
  snapshot_timestamp,
  starred_at,
  updated_at
)
select
  ue.user_id,
  elem->>'message_id' as message_id,
  coalesce(elem->>'content', '') as snapshot_content,
  case when elem->>'content_type' = 'user' then 'user' else 'assistant' end as snapshot_content_type,
  case
    when coalesce(elem->>'timestamp', '') ~ '^[0-9]{4}-[0-9]{2}-[0-9]{2}T'
      then (elem->>'timestamp')::timestamptz
    else coalesce(ue.updated_at, now())
  end as snapshot_timestamp,
  coalesce(ue.updated_at, now()) as starred_at,
  now() as updated_at
from public.user_essence ue
cross join lateral jsonb_array_elements(coalesce(ue.user_essence->'starred_message_snapshots', '[]'::jsonb)) as elem
where coalesce(trim(elem->>'message_id'), '') <> ''
on conflict (user_id, message_id)
do update
set
  snapshot_content = excluded.snapshot_content,
  snapshot_content_type = excluded.snapshot_content_type,
  snapshot_timestamp = excluded.snapshot_timestamp,
  updated_at = now();

insert into public.starred_messages (
  user_id,
  message_id,
  snapshot_content,
  snapshot_content_type,
  snapshot_timestamp,
  starred_at,
  updated_at
)
select
  ue.user_id,
  trim(message_id_raw) as message_id,
  '' as snapshot_content,
  'assistant' as snapshot_content_type,
  coalesce(ue.updated_at, now()) as snapshot_timestamp,
  coalesce(ue.updated_at, now()) as starred_at,
  now() as updated_at
from public.user_essence ue
cross join lateral jsonb_array_elements_text(coalesce(ue.user_essence->'starred_message_ids', '[]'::jsonb)) as message_id_raw
where coalesce(trim(message_id_raw), '') <> ''
on conflict (user_id, message_id) do nothing;

update public.user_essence
set
  user_essence = coalesce(user_essence, '{}'::jsonb) - 'starred_message_ids' - 'starred_message_snapshots',
  updated_at = now()
where user_essence ? 'starred_message_ids'
   or user_essence ? 'starred_message_snapshots';

alter table public.starred_messages enable row level security;

drop policy if exists "Users can read own starred messages" on public.starred_messages;
create policy "Users can read own starred messages"
  on public.starred_messages for select
  to authenticated
  using (auth.uid() = user_id);

drop policy if exists "Users can insert own starred messages" on public.starred_messages;
create policy "Users can insert own starred messages"
  on public.starred_messages for insert
  to authenticated
  with check (auth.uid() = user_id);

drop policy if exists "Users can delete own starred messages" on public.starred_messages;
create policy "Users can delete own starred messages"
  on public.starred_messages for delete
  to authenticated
  using (auth.uid() = user_id);

drop policy if exists "Users can update own starred messages" on public.starred_messages;
create policy "Users can update own starred messages"
  on public.starred_messages for update
  to authenticated
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

grant select, insert, update, delete on table public.starred_messages to authenticated;
grant usage, select on sequence public.starred_messages_id_seq to authenticated;

commit;
